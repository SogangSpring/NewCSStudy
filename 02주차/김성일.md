# 2주차

## 네트워크 - HTTPS 동작 원리

### 대칭키 & 공개키

- 대칭키 암호 ( 비밀키 암호 )
  - 암호화 키와 복호화 키가 같음
  - 복호화를 위해 대칭키를 같이 보내야해서 문제가 생길 수 있음.
- 비대칭형 암호 ( 공개키 암호 )
  - 예시 ) RSA
  - 암호화키와 복호화 키가 다름
  - 암호화를 하면 하나의 키 쌍이 생기고, 두 개의 키를 각각 키 A, 키 B라고 했을 때 키 A로 암호화한 암호문은 키 B로만 복호화할 수 있고 키 B로 암호화한 암호문은 키 A로만 복호화할 수 있다. 따라서 이 중 하나의 키만 비밀로 보호하고(이를 '비밀키', '개인키'라고 한다) 다른 하나의 키는 공중에게 공개해도 관계가 없다(이를 '공개키'라고 부른다). 이렇게 둘 중 하나의 키는 반드시 공개되어야 통상적인 사용이 가능하므로 공개키 암호방식이라고함.
    - 송신자 A가 수신자 B에게 전송하려할 때, B가 공개키와 비공개키를 생성.
    - 공개키를 인터넷에 공개
    - A가 공개키를 이용하여 보내려는 정보를 암호화.
    - B가 받으면, 비공개키를 이용하여 복호화.
    - 중간에 누군가가 가로채도 공개키로는 복호화할 수 없음. 따라서 대칭형 암호에서 발생하는 문제가 x

++ 단방향 암호화

- 해싱을 이용해 평문을 암호문으로 암호화하는 것은 가능하지만 **암호문을 평문으로 복호화 하는것은 불가능**
- 무작위 대입을 통한 해시키를 찾을 수도 있음. ( 레인보우 테이블 공격 )



### HTTP & HTTPS

- HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있음.

- 따라서 보안이 취약해짐을 알 수 있습니다. 

- 이를 보완하기 위해 나온 것이 HTTPS.

- 중간에 암호화 계층을 거쳐서 패킷을 암호화합니다.

이러한 HTTPS는 결국 HTTP에 보안을 위한 계층을 추가한 것으로, 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용.



### TLS/SSL Handshake

- HTTPS의 작동원리

- HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.

- 제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.
  
  클라이언트는 **TCP 3way handshake를 수행**한 이후 **Client Hello를 전송**합니다. **서버는 인증서를 보냅니다**.(다른 정보들도 전송하나 검색을 통해 알 수 있는 부분입니다. 대개 그 정도까지는 요구하지 않습니다.)
  
  클라이언트는 받은 **인증서를 신뢰하기 위해서 등록된 인증기관인지 확인**합니다. 이 인증서는 인증기관의 개인키로 암호화되어있고, **공개키로 검증**할 수 있습니다.(브라우저에 내장되어있음) **클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.**
  
  **서버의 공개키로 통신에 사용할 비밀키를 암호화**해서 서버에 보냅니다. **서버는 이를 개인키로 확인**하고 이후 **통신은 공유된 비밀키로 암호화되어 통신**합니다
  
  ⇒ 인증서 인증 ( 인증기관의 개인키로 암호화, 공개키로 복호화 )
  
  ⇒ 이를 통한 서버의 공개키 획득
  
  ⇒ 서버의 공개키로 클라이언트는 사용할 비밀키를 암호화
  
  ⇒ 서버는 그걸 받으면 개인키로 복호화해서 공유된 비밀키로 통신을 암호화하여 사용



## 네트워크 - 기타

### CORS

> Cross-Origin Resource Sharing 교차 출처 리소스 공유라는 뜻으로, 이 정책 위반에의한 에러는 웹 개발을하다보면 흔하게 마주하게 됨.

일단 이것을 알아보기 위해서는 "교차 출처" 라는 것에 집중을 해야함.

먼저 **출처**란?

- 서버의 위치를 의미하는 도메인 혹은 IP 주소를 보면 여러 요소로 이루어져 있음.

- protocol - host - port - path - query - fragment 와 같이 여러 종류로 나누어져 있음.
  
  예를 들어 https://google.com/search?keyword=hello#foo 와 같은 url은 아래와 같이 구분할 수 있음.
  
  | name     | example        |
  | -------- | -------------- |
  | protocol | https://       |
  | host     | google.com     |
  | port     | 80             |
  | path     | search         |
  | query    | ?keyword=hello |
  | fragment | #foo           |

- 위와 같은 예시에서 출처는 protocol + host + port를 합친 개념으로 이해하면 됨.

CORS는 교차 출처에서 리소스 교환, 즉 **서로 다른 출처에서 리소스를 교환하는 행위**를 뜻하고 이것은 기본적으로 제한 되어 있음.

이러한 교차출처에서의 리소스 교환은 생각해보면, 위험한 상황일 수 있음.

다른 곳에서 들어오는 요청을 아무렇지않게 허용하다보면, 공격에는 당연히 취약해질 수 밖에 없고.. 그렇기 때문에 기본적으로는 CORS를 통해 제한을 두는 것.

이 에러를 해결하는 방법은?

- Access-Control-Allow-Origin 헤더 설정

보통 가장 많이 사용하는 방법이며, 가장 안일하게 세팅하는 경우가 많은 방법.

여러 코드를 봤을 때.. 그리고 직접 했을 때도 귀찮아서..라는 이유로 Access-Control-Allow-Origin에 * 라는 wildcard를 쓰는 경우가 많음.

위 설정은 어떤 출처에서 오는 요청이라도 상관없이 모두 허용하겠다라는 뜻.

그러니까 이러한 요청을 허용하지말고.. 제발 우리는 적절한 곳에서만 요청 가능하게 설정합시다.



### REST API

- REpresentational State Transfer API
  
  - API
    - Application Programming Interface

- 로이필딩의 박사 학위 논문에서 최초로 소개 됨

- 자원, 행위, 표현으로 나뉘는 구성을 가짐

- 특징
  
  - uniform 인터페이스
    - Uniform Interface는 **URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행**하는 아키텍처 스타일
  - stateless
    - 작업을 위한 **상태정보를 따로 저장하고 관리하지 않습니다**. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리.
  - cacheable
    - **HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다.** 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 **Last-Modified태그나 E-Tag를 이용하면 캐싱 구현**
  - self-descriptiveness
    - REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 **자체 표현 구조**
  - client-server
    - **REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리**하는 구조로 각각의 역할이 확실히 구분
  - 계층형 구조
    - **다중 계층으로 구성 가능**
    - **사용자인증, 암호화, 로드밸런싱을하는 계층 등을 추가가능**

- 디자인 가이드
  
  - **첫 번째,** URI는 정보의 자원을 표현해야 한다.
    - 리소스 명은 동사보다 명사를 사용
  - **두 번째,** 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.
  
  ex) delete /members/1

- 메소드
  
  ![](/Users/seongilkim/NewCSStudy/2주차/img_김성일/rest.png)
  
  멱등성 : 같은 작업을 반복해도 같은 결과가 나오는 경우
  
  OPTIONS, HEAD, TRACE의 존재에 대해서는 알아만 둡시다. 특히 TRACE는 몰라도 되는 것 같습니다. OPTIONS는 해당 uri에 대해 서버가 허용하는 메서드를 확인할 때 사용합니다. HEAD는 GET과 비슷하나 header만 가져옵니다.
  
  - POST : 리소스 생성
  - GET : 리소스 조회
  - PUT : 리소스 수정 하거나 생성
    - 전부 변경 ( 전체가 아닌 일부만 보낼경우, 전달한 필드 외 전부 null or 초기값처리 )
    - 캐시 불가
  - patch : 리소스 수정 하거나 생성
    - 일부만 변경
  - delete : 리소스 삭제

- HATEOAS
  
  - Hypermedia As the engine of application state
  - 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것
  - **API에서 리소스에 대해 어떠한행동을 할 수 있는지 URL을 전달.**
  - 해당 리소스의 상태에 따라 링크정보가 바뀌며 동적으로 리소스 구성
  - application/hal+json 으로 전달하면 클라이언트는 _links 필드에 링크 정보를 가지고 있다고 예상 가능
  - ex) 예약의 상태에 따라 시술완료가 가능하면 시술 완료 처리를 할 수 있는 링크를 포함해 응답 처리

### DNS

> Domain Name System은 호스트의 도메인 이름을 호스트의 네트워크 주소(ip)로 바꾸거나 변환을 수행할 수 있도록하기 위해 만들어진 시스템.


이러한 DNS를 운영하는 서버를 네임서버라고 하며, DNS는 결국 Domain과 IP 간의 상호 변환 시스템이다.

![](img_김성일/dns.png)

DNS는 보통 트리 구조와 같은 형식으로 이루어져있어서, Local DNS Server가 도메인에 해당하는 IP를 찾지 못하면 Root DNS Server에게 물어보고 Root DNS Server는 차례로 아래를 타고 내려가면서 IP를 찾음.

DNS가 이렇게 IP를 찾아가는 과정을 Resolving이라하고, Resolver가 이 역할을 함.

Recursive, Iterative 한 방법으로 보통 나뉘는데 이 방법은 다른 참고자료를 통해 더 공부하도록 하자.

그리고 이러한 DNS를 통해 알아낸 IP는 PC의 DNS Cache에 저장되어 자주쓰는 Domain은 굳이 DNS를 찾는 과정을하지 않아도 내부에서 IP를 찾을 수 있도록 함.


### CSRF

> **C**ross-**S**ite **R**equest **F**orgery 으로, 간단하게 말하자면 사이트간의 요청 위조를 통해 웹 사이트의 취약점을 찾아 공격하는 방식.

예를 들어, 어떤 사이트에 로그인되어 있는 사용자에게 사이트를 분석해 얻은 취약점을 이용하여 만든 가짜 사이트를 메일로 보내 그걸 동작시킴으로써 권한을 탈취하거나 마음대로 글을 쓰는 등의 행위가 CSRF 공격.

이러한 CSRF 공격을 막기위한 방법이 여러가지가 있는데 대표적인 2가지는 아래와 같다.

1. Referer Check
   - 백엔드에서 request의 referer를 확인하여 도메인 일치 여부를 검증하는 방법.
   - 일반적으로 이 방법으로 대부분 해결이 가능. 
2. CSRF Token 사용
   - 임의의 난수를 통해 만든 CSRF Token을 세션에 저장.
   - 사용자는 그 Token을 매 요청마다 난수 값에 포함시켜 전송
   - 백엔드는 요청마다 세션의 토큰 값과 요청의 토큰 값을 비교.   