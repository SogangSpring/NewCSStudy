# 이상(Anomaly)

[참고](https://rebro.kr/159)

이상현상이란 테이블 내의 데이터들이 불필요하게 중복되어 데이터를 조작할 때 발생되는 불일치 현상이다. 3가지 종류가 있으며 정규화를 통해서 이상현상을 막을 수 있다.

![1](./img_김현우/1.png)

위와 같은 표가 있다고 하자


1. 삽입이상
    
    위의 표에서 다음과 같은 자료를 삽입한다고 가정하자

    ![2](./img_김현우/2.png)
    
    강의를 수강하지 않은 학생의 정보를 삽입하고 싶을 때 과목 번호와 성적에 관한 정보가 없게 되므로 삽입을 할 때 과목 번호와 성적에 NULL값을 넣어줘야 하는 문제가 생긴다.

2. 삭제 이상

    ![3](./img_김현우/3.png)

    학번 300번이 과목 C-73을 들었다는 사실을 삭제하려고 했지만 지도 교수와 같은 정보도 모두 사라지게 된다.

3. 갱신 이상

    위의 표에서 123번 학생의 지도교수가 바뀌게 된다면 모든 튜플에서 123의 지도교수는 P1이 아닌 다른 값이 되어야 하나, 갱신 이상이 발생하면 갱신하지 않은 정보와 갱신한 정보간의 충돌이 발생한다.

# 정규화(Nomalization)

Relation을 분해하여 이상현상을 없에는 과정, 종속성을 없에는 방향으로 움직인다.

## 함수 종속성

* 데이터들이 기준값에 대해 종속되는 현상

* X에 대해서 오직 하나의 Y만이 존재하면 Y는 X에 함수적으로 종속한다고 하고, 기호로는 X→Y라고 표기한다. 여기서 X는 **결정자** Y는 **종속자**라고 한다.

## 함수 종속성의 유형

1. 완전 함수 종속

    X'⊂X 이고 X'→Y를 만족하는 attribute X'가 존재하지 않는다. 다르게 말해서 attribute가 2개 이상인 기본키가 있을 때 어느 한 쪽이라도 단독으로 함수 종속성이 성립하면 안 된다는 의미이다.

2. 부분 함수 종속
    
    X'⊂X 이고 X'→Y를 만족하는 attribute X'가 존재한다는 의미이다. attribute중 1개가 단독으로 함수 종속성이 성립한다는 의미이다.

3. 이행 함수 종속성
    
    relation에 atttribute X Y Z 가 있을 때 X→Y, Y→Z가 성립할 때 X→Z가 성립하면 이행적 함수 종속성이 성립한다고 한다.

## 원칙

정규화는 다음과 같은 3가지 원칙을 따른다.

1. 정보의 무손실

    분해된 릴레이션이 표현하는 정보는 분해전의 모든 정보를 담고 있어야 한다.

2. 데이터 중복성 감소
    
    중복으로 인한 이상현상(anamoly)감소

3. 분리의 원칙
    
    하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리하여 표현(1차 정규화 예외)

## 유형

유형은 다음과 같은 5가지 유형이 존재한다.

### 기초적 정규화

*  1차 정규화

    * 반복되는 속성제거 
    * relation에 존재하는 모든 domain이 원자값(attribute 하나에 한개의 atrribute)만으로 되어있는 경우

* 2차 정규화

    * 부분함수 종속성을 제거한다.
    * 1차 정규화를 마치고 기본키가 아닌 attribute가 기본키에 종속할 경우
    * 결정자가 2개 이상일 때, 2개중 하나의 결정자에 의해서만 함수 종속성인 경우(쉽게 말해서 하나의 Y값에 대해 하나의 X값만 존재해야 한다는 뜻)

* 3차 정규화

    * 이행함수의 종속성을 제거한다.
    * 2차 정규화를 완료하고, 기본키 이외의 attribute간에 함수적 종속석을 지니지 않는다.

* Boyce-Codd Normal Form(BCNF)
    * 결정자의 함수 종속성 제거
    * relation의 모든 결정자가 후보키이다.


### 진보적 정규화

*  4차 정규화

    * 다중값 종속성 제거
    * BCNF이고 relation 내부의 모든 attribute 에 대해서 A->X이고 A가 후보키이다.

* 5차 정규화

    * 결합 종속성 제거
    * relaion에 존재하는 모든 join dependency가 후보키를 통해서만 성립하는 경우


# 인덱스(INDEX)

https://coding-factory.tistory.com/746

데이터베이스의 테이블에 대한 검색 속도를 높여주는 자료구조이다. 

## 사용 이유(장점)

![4](./img_김현우/4.png)

* 다음과 같이 Table에 자료가 있다고 하자, SELECT 문을 쓰게 된다면 INDEX가 존재하지 않는다면  company_id 가 18인 튜플을 찾을 때 Table을 처음부터 끝까지 찾게 된다. 매번 자료를 찾을 때 마다 Full Table Scan을 하게 되면 효율성이 메우 떨어지게 된다. Index를 만들어서 Index내부에서 company_id가 18인 자료의 위치를 모아놓게 되면 일일히 Table안에서 Full Scan을 할 필요가 없게 된다. 

* 또한 정렬을 할 때도 미리 정렬을 해서 Index에 넣어놓게 되면 Order by문을 쓸 때 효율적이다.

* 최대 최소를 찾을 때도 Full Table Scan을 할 필요 없이 정렬 된 자료 값에서 맨 앞과 뒤만 살피면 되기 때문에 효율적이다.

## 단점

* 위에서 얘기를 한 것과 같이 항상 정렬이 된 상태가 유지가 되야 하는데 이로 인해서 자료가 추가되거나 바뀌거나 삭제되면 오버헤드가 발생한다. 그러므로 INDEX에서는 바뀌거나 삭제하는 연산을 해당 자료를 사용하지 않는 것으로 연산을 대신한다. 이렇게 계속 자료가 추가 되거나 삭제가 되면 결국에는 INDEX가 Table의 크기를 넘어가는 순간이 생기게 된다.

## 사용처

* 위의 장점과 단점을 생각해보면 INDEX는 결국 자료의 수정과 삭제가 적게 일어나고 SELECT와 ORDER BY 연산이 자주 일어나며 자료의 크기가 큰 relation에 쓰면 된다.


# 트랜잭션(Transaction)

트렌섹션이란 **하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산을 모아놓은 것으로써**  논리적인 작업단위로써 오류가 발생했을 때 데이터를 복구하는 작업의 단위이다.


## 트랜섹션의 요소(ACID)

1. Atomicity(원자성)

    * 트랜섹션을 이루는 연산이 모두 실행되거나 모두 실행이 되지 않아야 한다는 의미

    * 만약 장애가 발생하면 트랜섹션 자체에서 일어난 모든 연산을 취소한다.

2. Consistency(일관성)

    * 트랜섹션이 성공한 이후에도 데이터베이스가 일관성을 유지해야 한다는 의미

    * 예시) 창고간에 물건을 주고 받더라도 각 창고의 물건의 합은 트랜섹션 이전과 이후가 같아야 한다는 뜻

3. Isolation(격리성)

    * 현재 수행중인 트랜섹션이 완료되기 전까지 다른 트렌섹션은 현재 트랜섹션이 수행하는 계산값에 접근할 수 없음을 의미

    * 여러 트랜섹션이 실행 되더라도 다른 트렌섹션의 계산 결과는 건드릴 수 없다.

4. Durability(지속성)

    * 계산결과 이후에 데이터베이스에 반영된 결과는 어떠한 경우에도 손실되면 안된다는 뜻

## 트랜섹션의 연산

1. Commit

    ![5](./img_김현우/5.png)

    * 트랜섹션이 성공적으로 종료 되었다는 것을 트렌섹션 관리자에 알려준다.

2. Rollback

    ![6](./img_김현우/6.png)

    * 트랜섹션 중간에 계산이 중단되면 트랜섹션에서 실행된 연산을 모두 폐기하고 실행되기 이전으로 돌아간다.

## 트랜섹션의 상태

![7](./img_김현우/7.png)


* 활동상태
    
    현재 트랜섹션 실행중인 상태

* 부분 완료

    트랜섹션의 연산을 실행하였지만, commit이 완료되기 전의 상태

* 완료 상태

    commit 까지 완료 된 상태

* 실패 상태

    트랜섹션에 오류가 발생한 상태

* 철회 상태

    트랜섹션이 오류를 일으켜서 rollback을 수행한 상태


# 트랜섹션 격리 수준(Transaction Isolation Level)

[참고](https://dar0m.tistory.com/225)

## 생기는 문제점

    트랜섹션을 제대로 처리하지 않으면 다음과 같은 3가지 문제가 발생한다

1. Dirty Read

    * 어떤 트랜섹션이 끝나지 않은 상태에서 다른 트랜섹션이 접근을 하게 되면 갱신되지 않은 데이터를 

2. Non-Reapeatable Read

    * 한 트랜섹션에서 같은 쿼리를 두번 실행 할 때, 두 쿼리의 결과가 상이하게 나타나는 현상

3. Phantom Read

    * 일정 범위의 레코드를 두 번 읽을 때, 이전에 없던 유령 레코드가 나타나는 현상

    * 다른 트랜섹션이 작업중이어도 레코드를 삽입 가능하게 해서 생기는 문제

## 종류

트랜섹션에는 4가지 격리 수준이 존재한다.

1. Read Uncommited(레벨 0)

    * 해당 트랜섹션의 내용이 아무런 제약조건 없이 다른 트랜색션도 접근이 가능하다.

    * 데이터의 일관성이 유지되지 않는다.

    * Dirty Read, Non-Repeatable Read, Phantom Read 발생

2. Read Commmited(레벨1)

    * 트랜섹션의 변경 내용이 commit 되어야 다른 트랜섹션에서 접근이 가능하다.

    * 읽기를 수행해도 다른 트랜섹션은 접근이 가능하다

    * Non-Repeated Read가 나타난다.(한 트랜섹션 안에서  같은 자료에 대한 두 번의 select의 결과가 다르게 나타난다)

3. Repeatable Read(레벨2)

    * 트랜섹션이 시작되기 전에 commit된 내용만 조회 가능

    * 한 트랜섹션 내에서 조회하는 데이터는 항상 동일

    * Phantom Read발생

4. Serializable(레벨 3)

    * 가장 엄격한 격리 수준이다.

    * 다른 트랜섹션은 그 영역에 대한 수정과 입력이 불가능(레코드 삽입도 불가)

    * 효율이 떨어진다.

# Array

## 특징

* 데이터 여러개를 순차적으로 나열한 자료구조이다.
* 연속적인 메모리 공간에 순차적으로 나열했다.
* 선언한 이후에 크기는 고정이다.

## 장점

* random access 에 매우 강하다. 시간 복잡도가 1이다.
* 구현이 쉽다.
* 연속적인 공간이므로 cache hit이 자주 발생한다.

## 단점

* 선언한 이후에 크기가 고정이므로 크기가 커지지 않는다.
* 자료 삽입이나 삭제가 일어날 때 모든 데이터를 옮겨야 하므로 시간 복잡도가 n이다.
* 사용하지 않는 공간도 할당을 해야 하므로 메모리 낭비가 발생한다.

# LinkedList

## 특징

* 인덱스가 없는 대신 배열과 달리 빈 자료는 허용하지 않음
* 빈틈 없는 데이터의 적재가 특징
* 배열과 달리 연속적인 공간에 존재하지 않는다.

## 장점

* 데이터의 삭제를 할 때 시간복잡도가 1이다.
* 배열과 달리 동적인 데이터의 추가 삭제가 가능하다.
* 불연속적이므로 메모리 관리가 수월하다.

## 단점

* 조회(random access)를 할 때 시간 복잡도가 n이 된다.
* 원소들을 조회를 계속 하지 않으면 메모리 낭비가 심해진다.
* 다음 원소를 가르키는데 추가적인 메모리 소비가 일어난다.

# Array & ArrayList & LinkedList


## Array vs ArrayList

* 둘다 Array 라는 점은 동일하지만 Array는 동적인 할당이 안되고 ArrayList는 동적으로 할당이 가능하다는 점이 차이가 있다.

* Array는 한번 선언한 배열에서 크기가 변할 수 없지만 ArrayList는 크기에 맞춰서 배열의 크기가 변한다.


## Array vs LinkedList

* 배열과 달리 LinkedList는 물리적 저장순서와 논리적 저장 순서가 일치하지 않는다.

* 배열은 원소의 추가와 삭제가 힘들지만 LinkedList는 원소의 추가와 삭제가 쉽다.

* LinkedList는 원소를 조회하는 속도가 느리다.